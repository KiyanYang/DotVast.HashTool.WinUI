using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml.Linq;

using DotVast.Toolkit.StringResource.Attributes;
using DotVast.Toolkit.StringResource.SourceGenerator;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotVast.ToolKit.StringResource.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class StringResourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<StringResourceInfo> strReswInfos = context.SyntaxProvider
                               .CreateSyntaxProvider(CouldBeGenerateStringResource, GetStringResourceInfo)
                               .Where(type => type != null)!;

        var infos = strReswInfos
            .Where(i => File.Exists(i.ReswPath));

        context.RegisterSourceOutput(infos, GenerateCode);
    }

    private static bool CouldBeGenerateStringResource(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = attribute.Name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };

        if (name is not ("StringResource" or "StringResourceAttribute"))
            return false;

        var hasPathProperty = attribute!.ArgumentList?.Arguments
            .Any(a => a.NameEquals?.Name.Identifier.ValueText == "Path");

        if (hasPathProperty == false)
            return false;

        // attribute.Parent is AttributeListSyntax
        // attribute.Parent.Parent is the attributeTarget
        if (attribute.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return false;

        // check partial class
        return classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static StringResourceInfo? GetStringResourceInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attribute = (AttributeSyntax)context.Node;
        var classDeclaration = (ClassDeclarationSyntax)context.Node.Parent!.Parent!;

        if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is not ISymbol attr)
            return null;

        if (attr.ContainingType.ToDisplayString() != "DotVast.Toolkit.StringResource.Attributes.StringResourceAttribute")
            return null;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not ITypeSymbol type)
            return null;

        var relativePath = GetAttributeArgumentValue(attribute, nameof(StringResourceAttribute.Path));

        if (relativePath == null)
            return null;

        var basePath = classDeclaration.SyntaxTree.FilePath;

        return new StringResourceInfo(type, Path.Combine(basePath, relativePath))
        {
            ExMethed = GetAttributeArgumentValue(attribute, nameof(StringResourceAttribute.ExtensionMethod)),
            ExMethedNamespace = GetAttributeArgumentValue(attribute, nameof(StringResourceAttribute.ExtensionMethodNamespace))
        };
    }

    private static string? GetAttributeArgumentValue(AttributeSyntax attribute, string name) =>
        attribute.ArgumentList?.Arguments
            .Where(a => a.NameEquals?.Name.Identifier.ValueText == name)
            .Select(a => (a.Expression as LiteralExpressionSyntax)?.Token.ValueText)
            .FirstOrDefault();

    private static void GenerateCode(SourceProductionContext context, StringResourceInfo info)
    {
        var ns = info.Namespace;
        var cls = info.Name;
        var path = info.ReswPath;
        var xEle = XElement.Load(path);
        var exMethed = info.ExMethed;
        var exMethedNs = info.ExMethedNamespace;
        var sb = new StringBuilder();

        sb.Append(@$"// <auto-generated/>
#pragma warning disable
#nullable enable

{(exMethedNs != null ? $"using {exMethedNs};" : string.Empty)}

namespace {ns}
{{");
        sb.Append(@$"
   partial class {cls}
   {{");

        foreach (var item in xEle.Elements("data"))
        {
            if (item.Attribute("name")?.Value is not string name
                || name.Contains("."))
                continue;

            if (item.Element("value")?.Value is string value)
                sb.Append($@"
        ///<value>
        /// {value}
        /// </value>");

            if (item.Element("comment")?.Value is string comment)
                sb.Append($@"
        ///<remarks>
        /// {comment}
        /// </remarks>");

            sb.Append($@"
        public static string {name} => ""{name}""{(exMethed != null ? $".{exMethed}()" : string.Empty)};
");
        }
        sb.Append($@"}}
}}
");

        context.AddSource($"{ns}{cls}.g.cs", sb.ToString());
    }
}
