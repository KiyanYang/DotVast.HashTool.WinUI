// Copyright (c) Kiyan Yang.
// Licensed under the MIT License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DotVast.HashTool.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class NativeCryptoGenerator : IIncrementalGenerator
{
    private const string NativeCryptoAttributeName = "DotVast.HashTool.NativeCrypto.NativeCryptoAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider
            .ForAttributeWithMetadataName(NativeCryptoAttributeName, Predicate, Transfrom)
            .Where(static i => i != default);

        context.RegisterSourceOutput(infos, GenerateCode);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token) =>
        node is ClassDeclarationSyntax;

    private static (string, string, string, string, int) Transfrom(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        if (context.TargetSymbol is not ITypeSymbol type)
        {
            return default;
        }

        // context.Attributes 仅包含目标特性
        if (GetAttributeCtorArgsValue(context.Attributes.FirstOrDefault()) is not object[] args
         || args.Length != 3
         || args[0] is not string feature
         || args[1] is not string fnPrefix
         || args[2] is not int hashSizeInBytes)
        {
            return default;
        }

        var className = type.Name;
        var namespaceName = type.ContainingNamespace.ToDisplayString();

        return (className, namespaceName, feature, fnPrefix, hashSizeInBytes);
    }

    private static void GenerateCode(SourceProductionContext context, (string, string, string, string, int) info)
    {
        var className = info.Item1;
        var namespaceName = info.Item2;
        var feature = info.Item3;
        var fnPrefix = info.Item4;
        var hashSizeInBytes = info.Item5;

        context.AddSource($"{namespaceName}.{className}.g.cs", $$"""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable

            #if Benchmark || {{feature}}

            namespace {{namespaceName}};

            sealed partial class {{className}} : DotVast.HashTool.NativeCrypto.NativeCryptoBase
            {
                public {{className}}()
                {
                    HashSizeValue = {{hashSizeInBytes}};
                }

                protected override nuint New() => NativeMethods.{{fnPrefix}}_new();
                protected override void Reset() => NativeMethods.{{fnPrefix}}_reset(_hasher);
                protected override void Update(in byte input, int size) => NativeMethods.{{fnPrefix}}_update(_hasher, input, size);
                protected override void Finalize(ref byte output, int size) => NativeMethods.{{fnPrefix}}_finalize(_hasher, ref output, size);
                protected override void Free() => NativeMethods.{{fnPrefix}}_free(_hasher);
            }

            partial class NativeMethods
            {
                [System.Runtime.InteropServices.DllImportAttribute(DllName, EntryPoint = "{{fnPrefix}}_new", ExactSpelling = true)]
                internal static extern nuint {{fnPrefix}}_new();

                [System.Runtime.InteropServices.DllImportAttribute(DllName, EntryPoint = "{{fnPrefix}}_reset", ExactSpelling = true)]
                internal static extern void {{fnPrefix}}_reset(nuint ptr);

                [System.Runtime.InteropServices.DllImportAttribute(DllName, EntryPoint = "{{fnPrefix}}_update", ExactSpelling = true)]
                internal static extern void {{fnPrefix}}_update(nuint ptr, in byte input, int size);

                [System.Runtime.InteropServices.DllImportAttribute(DllName, EntryPoint = "{{fnPrefix}}_finalize", ExactSpelling = true)]
                internal static extern void {{fnPrefix}}_finalize(nuint ptr, ref byte output, int size);

                [System.Runtime.InteropServices.DllImportAttribute(DllName, EntryPoint = "{{fnPrefix}}_free", ExactSpelling = true)]
                internal static extern void {{fnPrefix}}_free(nuint ptr);
            }

            #endif
            """);
    }

    private static object?[]? GetAttributeCtorArgsValue(AttributeData? attributeData) =>
        attributeData?.ConstructorArguments.Select(arg => arg.Value).ToArray();
}
