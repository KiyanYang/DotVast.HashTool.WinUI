// <auto-generated/>

#if Benchmark || ripemd

using DotVast.Hashing;

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace DotVast.HashTool.NativeCrypto;

public sealed partial class RIPEMD320 : IHasher
{
    private sealed class RIPEMD320Handle : HasherHandle
    {
        protected override void Free() => ripemd320_free(handle);
    }

    private readonly RIPEMD320Handle _handle = ripemd320_new();

    public int HashLengthInBytes => 40;

    public void Reset() => ripemd320_reset(_handle);

    public void Append(ReadOnlySpan<byte> source) => ripemd320_update(_handle, source, source.Length);

    public byte[] GetCurrentHash()
    {
        var ret = new byte[40];
        ripemd320_finalize(_handle, ret, 40);
        return ret;
    }

    [LibraryImport("native_crypto", EntryPoint = "ripemd320_new")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    private static partial RIPEMD320Handle ripemd320_new();

    [LibraryImport("native_crypto", EntryPoint = "ripemd320_reset")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    private static partial void ripemd320_reset(RIPEMD320Handle hasherHandle);

    [LibraryImport("native_crypto", EntryPoint = "ripemd320_update")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    private static partial void ripemd320_update(RIPEMD320Handle hasherHandle, ReadOnlySpan<byte> input, int size);

    [LibraryImport("native_crypto", EntryPoint = "ripemd320_finalize")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    private static partial void ripemd320_finalize(RIPEMD320Handle hasherHandle, Span<byte> output, int size);

    [LibraryImport("native_crypto", EntryPoint = "ripemd320_free")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]
    private static partial void ripemd320_free(nint hasherPtr);
}

#endif
